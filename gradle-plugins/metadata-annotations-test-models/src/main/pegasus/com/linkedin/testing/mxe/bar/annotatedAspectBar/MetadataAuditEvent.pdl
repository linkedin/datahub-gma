namespace com.linkedin.testing.mxe.bar.annotatedAspectBar

import com.linkedin.avro2pegasus.events.KafkaAuditHeader
import com.linkedin.metadata.events.ChangeType
import com.linkedin.metadata.events.IngestionTrackingContext
import com.linkedin.testing.BarUrn
import com.linkedin.testing.AnnotatedAspectBar

/**
 * MetadataAuditEvent for the BarUrn with AnnotatedAspectBar aspect.
 */
@MetadataAuditEvent
record MetadataAuditEvent {

  /**
   * Kafka audit header for the MetadataAuditEvent.
   */
  auditHeader: optional KafkaAuditHeader

  /**
   * BarUrn as the key for the MetadataAuditEvent.
   */
  urn: BarUrn

  /**
   * Aspect of the AnnotatedAspectBar before the update.
   */
  oldValue: optional AnnotatedAspectBar

  /**
   * Aspect of the AnnotatedAspectBar after the update.
   */
  newValue: AnnotatedAspectBar

  /**
   * Change type.
   */
  changeType: optional union[null, ChangeType] = null

  /**
   * Tracking context to identify the lifecycle of the trackable ingestion item.
   */
  ingestionTrackingContext: optional union[null, IngestionTrackingContext] = null

  /**
   * Flag to indicate if the event is a backfill request for audit data. True if the event is a backfill request.
   * False and null mean it's not.
   *
   * Historically, the term "backfill" in gma may refer to
   * 1. hitting the rest.li backfill endpoint of a resource
   * 2. bootstrap a new aspect/entity in the graph store from scratch. if the oldValue and the newValue are the same,
   * we treat it as a bootstrap mae and only consume it if a specific config is enabled.
   *
   * The field here indicates it's a backfill request resulted from 1, and should overwrite secondary store in live
   * regardless of the config mentioned in 2.
   */
  isBackfill: optional boolean
}